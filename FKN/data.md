### Массив

индекс изначально это сдвиг адреса массива чтобы получить i-тый элемент

поэтому нумерация с нуля

```c
a = [1, 2, 3]

a[0] = 1
a + 0 = 1

1[a] = 2
1 + a = 2


a[2] = 2[a]
```

# Структура данных

## виды описаний:
- Абстрактоное описание интерфейсов (неважно как работает нужно знать какие есть действия/операции)
- Абстрактоное описание интерфейсов + требование по сложности (есть требование по сложности)
- Реализация интерфейсов с заданой сложностью


## Абстрактное описание

### Cтек (FILO - first in last out)
- **push(a)** - добавить элемент на верхний конец
- **top(a)** - посмотреть на вверхний элемент
- **pop()** - достать верхний элемент
- **size()** - число элементов
- **is_empty()** - узнать пустой ли стек

### Очередь (FIFO)
- **enqueue(a)** - добавить элемент в конец
- **front(a)** - посмотреть на последний элемент
- **back()** - посмотреть на первй элемент
- **dequeue()** - достать первый элемент
- **size()** - число элементов
- **is_empty()** - узнать пустой ли стек


## Реализации (к примеру массива)

### Массив
аддрес в памяти и размер
обратится к любому элементу можно за $O(1)$ тк мы знаем где он находится (адресс + индекс)

Минус - чтобы вставтить элемент в массив приходится сдвигать всю остальную часть вправо

### Односвязный список
Элементы разбросаны в памяти в формате **[индекс следующего элемента][значение]**

Обратится к элементу теперь сложнее ($O(n)$) зато можно вставить элемент в список за $O(1)$

